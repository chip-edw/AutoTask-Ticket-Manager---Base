using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Hosting.Server;
using Microsoft.AspNetCore.Hosting.Server.Features;
using Serilog;

namespace xxAutoTaskTicketManager_Base
{
    public class Program
    {
        public static async Task Main(string[] args)
        {
            // Configure Serilog
            Log.Logger = new LoggerConfiguration()
                .ReadFrom.Configuration(new ConfigurationBuilder()
                    .SetBasePath(AppContext.BaseDirectory)
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .Build())
                .CreateLogger();

            var serverAddress = string.Empty;

            // Attach Global Handlers
            AttachGlobalHandlers();


            try
            {
                Log.Information("Starting the application...");

                // Create the WebApplication builder
                var builder = WebApplication.CreateBuilder(args);

                // Load configuration from appsettings.json
                builder.Configuration
                    .SetBasePath(AppContext.BaseDirectory)
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);

                var configuration = builder.Configuration;

                // Get the port for the management API from appsettings.json
                int managementApiPort = configuration.GetValue<int>("ManagementApiPort");

                // Configure Kestrel to listen on the specified port
                builder.WebHost.ConfigureKestrel(options =>
                {
                    options.ListenAnyIP(managementApiPort); // Bind to specified port
                });

                // Add services for the worker service
                builder.Services.AddHostedService<Worker>(); // Background worker
                builder.Services.AddScoped<IWorkerService, Worker>();

                var app = builder.Build();

                string workingDir = $"The working Dir is: {AppContext.BaseDirectory}\n";
                string dbError = "Could not find Database. Please validate SQLite DB is in the Application Root Directory and is populated correctly " +
                    "and the App configurations exist ";

                bool dataBaseAvailable = false; //Used to determine if the DB is available.

                //Get OS 
                var os = StartupConfiguration.DetermineOS();

                // Retrieve the DB path from appsettings.json
                string dbPath = configuration.GetConnectionString("DefaultConnection");

                string databasePath = configuration.GetConnectionString("DefaultConnection").Replace("Data Source=", string.Empty);


                if (File.Exists(databasePath))
                {
                    Console.WriteLine("Database exists.");

                    // Load the Application Configs from DB
                    dataBaseAvailable = StartupConfiguration.LoadProtectedSettings();
                }
                else
                {
                    Console.WriteLine("Database does not exist.");
                    // Handle the absence of the database file appropriately (e.g., create a new database, show an error, etc.)
                }


                // Access ServerFeatures via app.Services
                app.MapGet("/", (IServiceProvider services) =>
                {
                    var server = services.GetRequiredService<IServer>();
                    var serverAddresses = server.Features.Get<IServerAddressesFeature>()?.Addresses;
                    var listeningUrl = serverAddresses?.FirstOrDefault() ?? $"http://localhost:{managementApiPort}";
                    Log.Information("Management API is UP and listening at: {listeningUrl}", listeningUrl);

                    return $"Management API is UP and listening on: {listeningUrl}";
                });



                // Map additional endpoints in the ManagementAPI class
                ManagementAPI.ManagementAPI.Map(app);


                app.RunAsync(); // Run the application



            }
            catch (Exception ex)
            {
                Log.Fatal(ex, "The application failed to start.");
            }
            finally
            {
                Log.Information("Shutting down...");
                Log.CloseAndFlush();
            }
        }

        private static void AttachGlobalHandlers()
        {
            // Handle Unhandled Exceptions
            AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
            {
                Exception ex = args.ExceptionObject as Exception;
                Log.Fatal($"Unhandled exception: {ex?.Message}", ex);
            };

            // Handle Task Unobserved Exceptions
            TaskScheduler.UnobservedTaskException += (sender, args) =>
            {
                Log.Fatal($"Unobserved task exception: {args.Exception?.Message}", args.Exception);
                args.SetObserved(); // Prevents the process from being terminated
            };

            // Handle Process Exit
            AppDomain.CurrentDomain.ProcessExit += (sender, args) =>
            {
                Log.Information("Process is exiting. Performing cleanup...");
            };
        }
    }
}
